"""Monitoring and alerting system for AI Learning Accelerator."""

import asyncio
import time
from typing import Any, Dict, List, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
import statistics

from ..logging_config import get_logger

logger = get_logger(__name__)


class MetricType(str, Enum):
    """Types of metrics."""
    COUNTER = "counter"
    GAUGE = "gauge"
    HISTOGRAM = "histogram"
    TIMER = "timer"


class AlertSeverity(str, Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


@dataclass
class Metric:
    """A single metric measurement."""
    name: str
    value: float
    metric_type: MetricType
    timestamp: float = field(default_factory=time.time)
    tags: Dict[str, str] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "value": self.value,
            "type": self.metric_type.value,
            "timestamp": self.timestamp,
            "tags": self.tags
        }


@dataclass
class Alert:
    """An alert generated by the monitoring system."""
    name: str
    message: str
    severity: AlertSeverity
    timestamp: float = field(default_factory=time.time)
    tags: Dict[str, str] = field(default_factory=dict)
    resolved: bool = False
    resolved_at: Optional[float] = None
    
    def resolve(self):
        """Mark alert as resolved."""
        self.resolved = True
        self.resolved_at = time.time()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "message": self.message,
            "severity": self.severity.value,
            "timestamp": self.timestamp,
            "tags": self.tags,
            "resolved": self.resolved,
            "resolved_at": self.resolved_at
        }


class MetricCollector:
    """Collects and stores metrics."""
    
    def __init__(self, max_metrics: int = 10000):
        self.metrics: List[Metric] = []
        self.max_metrics = max_metrics
        self._lock = asyncio.Lock()
    
    async def record_metric(self, metric: Metric):
        """Record a metric."""
        async with self._lock:
            self.metrics.append(metric)
            
            # Keep only recent metrics
            if len(self.metrics) > self.max_metrics:
                self.metrics = self.metrics[-self.max_metrics:]
    
    async def increment_counter(self, name: str, value: float = 1.0, tags: Optional[Dict[str, str]] = None):
        """Increment a counter metric."""
        await self.record_metric(Metric(
            name=name,
            value=value,
            metric_type=MetricType.COUNTER,
            tags=tags or {}
        ))
    
    async def set_gauge(self, name: str, value: float, tags: Optional[Dict[str, str]] = None):
        """Set a gauge metric."""
        await self.record_metric(Metric(
            name=name,
            value=value,
            metric_type=MetricType.GAUGE,
            tags=tags or {}
        ))
    
    async def record_histogram(self, name: str, value: float, tags: Optional[Dict[str, str]] = None):
        """Record a histogram metric."""
        await self.record_metric(Metric(
            name=name,
            value=value,
            metric_type=MetricType.HISTOGRAM,
            tags=tags or {}
        ))
    
    async def record_timer(self, name: str, duration: float, tags: Optional[Dict[str, str]] = None):
        """Record a timer metric."""
        await self.record_metric(Metric(
            name=name,
            value=duration,
            metric_type=MetricType.TIMER,
            tags=tags or {}
        ))
    
    def get_metrics(
        self,
        name_filter: Optional[str] = None,
        since: Optional[float] = None,
        limit: Optional[int] = None
    ) -> List[Metric]:
        """Get metrics with optional filtering."""
        filtered_metrics = self.metrics
        
        if name_filter:
            filtered_metrics = [m for m in filtered_metrics if name_filter in m.name]
        
        if since:
            filtered_metrics = [m for m in filtered_metrics if m.timestamp >= since]
        
        if limit:
            filtered_metrics = filtered_metrics[-limit:]
        
        return filtered_metrics
    
    def get_metric_summary(self, name: str, since: Optional[float] = None) -> Dict[str, Any]:
        """Get summary statistics for a metric."""
        metrics = self.get_metrics(name_filter=name, since=since)
        
        if not metrics:
            return {"count": 0}
        
        values = [m.value for m in metrics]
        
        return {
            "count": len(values),
            "min": min(values),
            "max": max(values),
            "mean": statistics.mean(values),
            "median": statistics.median(values),
            "std_dev": statistics.stdev(values) if len(values) > 1 else 0.0,
            "latest": values[-1],
            "latest_timestamp": metrics[-1].timestamp
        }


class AlertManager:
    """Manages alerts and notifications."""
    
    def __init__(self, max_alerts: int = 1000):
        self.alerts: List[Alert] = []
        self.max_alerts = max_alerts
        self.alert_handlers: List[Callable[[Alert], None]] = []
        self._lock = asyncio.Lock()
    
    async def create_alert(self, alert: Alert):
        """Create a new alert."""
        async with self._lock:
            self.alerts.append(alert)
            
            # Keep only recent alerts
            if len(self.alerts) > self.max_alerts:
                self.alerts = self.alerts[-self.max_alerts:]
        
        # Notify handlers
        for handler in self.alert_handlers:
            try:
                if asyncio.iscoroutinefunction(handler):
                    await handler(alert)
                else:
                    handler(alert)
            except Exception as e:
                logger.error(f"Alert handler failed: {e}")
        
        logger.warning(
            "Alert created",
            alert_name=alert.name,
            severity=alert.severity.value,
            message=alert.message,
            tags=alert.tags
        )
    
    def add_alert_handler(self, handler: Callable[[Alert], None]):
        """Add an alert handler."""
        self.alert_handlers.append(handler)
    
    def get_active_alerts(self) -> List[Alert]:
        """Get all active (unresolved) alerts."""
        return [alert for alert in self.alerts if not alert.resolved]
    
    def get_alerts(
        self,
        severity: Optional[AlertSeverity] = None,
        since: Optional[float] = None,
        resolved: Optional[bool] = None
    ) -> List[Alert]:
        """Get alerts with optional filtering."""
        filtered_alerts = self.alerts
        
        if severity:
            filtered_alerts = [a for a in filtered_alerts if a.severity == severity]
        
        if since:
            filtered_alerts = [a for a in filtered_alerts if a.timestamp >= since]
        
        if resolved is not None:
            filtered_alerts = [a for a in filtered_alerts if a.resolved == resolved]
        
        return filtered_alerts
    
    async def resolve_alert(self, alert_name: str):
        """Resolve alerts by name."""
        async with self._lock:
            for alert in self.alerts:
                if alert.name == alert_name and not alert.resolved:
                    alert.resolve()
                    logger.info(f"Alert resolved: {alert_name}")


class HealthChecker:
    """Performs health checks on system components."""
    
    def __init__(self):
        self.health_checks: Dict[str, Callable[[], Dict[str, Any]]] = {}
        self.last_check_results: Dict[str, Dict[str, Any]] = {}
        self.check_interval = 60.0  # seconds
        self._running = False
        self._task: Optional[asyncio.Task] = None
    
    def register_health_check(self, name: str, check_func: Callable[[], Dict[str, Any]]):
        """Register a health check function."""
        self.health_checks[name] = check_func
        logger.info(f"Health check registered: {name}")
    
    async def run_health_check(self, name: str) -> Dict[str, Any]:
        """Run a specific health check."""
        if name not in self.health_checks:
            return {"status": "unknown", "error": f"Health check '{name}' not found"}
        
        try:
            check_func = self.health_checks[name]
            if asyncio.iscoroutinefunction(check_func):
                result = await check_func()
            else:
                result = check_func()
            
            result["timestamp"] = time.time()
            result["check_name"] = name
            self.last_check_results[name] = result
            
            return result
            
        except Exception as e:
            error_result = {
                "status": "error",
                "error": str(e),
                "timestamp": time.time(),
                "check_name": name
            }
            self.last_check_results[name] = error_result
            return error_result
    
    async def run_all_health_checks(self) -> Dict[str, Dict[str, Any]]:
        """Run all registered health checks."""
        results = {}
        
        for name in self.health_checks:
            results[name] = await self.run_health_check(name)
        
        return results
    
    async def start_periodic_checks(self):
        """Start periodic health checks."""
        if self._running:
            return
        
        self._running = True
        self._task = asyncio.create_task(self._periodic_check_loop())
        logger.info("Periodic health checks started")
    
    async def stop_periodic_checks(self):
        """Stop periodic health checks."""
        self._running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        logger.info("Periodic health checks stopped")
    
    async def _periodic_check_loop(self):
        """Periodic health check loop."""
        while self._running:
            try:
                await self.run_all_health_checks()
                await asyncio.sleep(self.check_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in health check loop: {e}")
                await asyncio.sleep(self.check_interval)
    
    def get_overall_health(self) -> Dict[str, Any]:
        """Get overall system health status."""
        if not self.last_check_results:
            return {"status": "unknown", "message": "No health checks performed yet"}
        
        all_healthy = all(
            result.get("status") == "healthy"
            for result in self.last_check_results.values()
        )
        
        if all_healthy:
            status = "healthy"
        else:
            failed_checks = [
                name for name, result in self.last_check_results.items()
                if result.get("status") != "healthy"
            ]
            status = "unhealthy" if len(failed_checks) > len(self.last_check_results) / 2 else "degraded"
        
        return {
            "status": status,
            "total_checks": len(self.last_check_results),
            "healthy_checks": sum(
                1 for result in self.last_check_results.values()
                if result.get("status") == "healthy"
            ),
            "last_check_time": max(
                result.get("timestamp", 0)
                for result in self.last_check_results.values()
            ) if self.last_check_results else None,
            "failed_checks": [
                name for name, result in self.last_check_results.items()
                if result.get("status") != "healthy"
            ]
        }


class MonitoringSystem:
    """Main monitoring system that coordinates all monitoring components."""
    
    def __init__(self):
        self.metrics = MetricCollector()
        self.alerts = AlertManager()
        self.health = HealthChecker()
        self._started = False
        
        # Set up default alert handlers
        self.alerts.add_alert_handler(self._log_alert)
    
    async def start(self):
        """Start the monitoring system."""
        if self._started:
            return
        
        await self.health.start_periodic_checks()
        self._started = True
        
        logger.info("Monitoring system started")
    
    async def stop(self):
        """Stop the monitoring system."""
        if not self._started:
            return
        
        await self.health.stop_periodic_checks()
        self._started = False
        
        logger.info("Monitoring system stopped")
    
    def _log_alert(self, alert: Alert):
        """Default alert handler that logs alerts."""
        logger.warning(
            f"ALERT [{alert.severity.value.upper()}]: {alert.message}",
            alert_name=alert.name,
            tags=alert.tags
        )
    
    async def record_request_metrics(self, method: str, path: str, status_code: int, duration: float):
        """Record HTTP request metrics."""
        tags = {"method": method, "path": path, "status_code": str(status_code)}
        
        await self.metrics.increment_counter("http_requests_total", tags=tags)
        await self.metrics.record_timer("http_request_duration", duration, tags=tags)
        
        # Create alerts for high error rates
        if status_code >= 500:
            await self.alerts.create_alert(Alert(
                name="high_error_rate",
                message=f"HTTP {status_code} error on {method} {path}",
                severity=AlertSeverity.ERROR,
                tags=tags
            ))
    
    async def record_ai_model_metrics(self, model_name: str, operation: str, duration: float, success: bool):
        """Record AI model performance metrics."""
        tags = {"model": model_name, "operation": operation, "success": str(success)}
        
        await self.metrics.increment_counter("ai_model_requests_total", tags=tags)
        await self.metrics.record_timer("ai_model_duration", duration, tags=tags)
        
        if not success:
            await self.alerts.create_alert(Alert(
                name="ai_model_failure",
                message=f"AI model {model_name} failed during {operation}",
                severity=AlertSeverity.WARNING,
                tags=tags
            ))
    
    async def record_database_metrics(self, operation: str, duration: float, success: bool):
        """Record database operation metrics."""
        tags = {"operation": operation, "success": str(success)}
        
        await self.metrics.increment_counter("database_operations_total", tags=tags)
        await self.metrics.record_timer("database_operation_duration", duration, tags=tags)
        
        if not success:
            await self.alerts.create_alert(Alert(
                name="database_failure",
                message=f"Database {operation} operation failed",
                severity=AlertSeverity.ERROR,
                tags=tags
            ))
    
    def get_system_status(self) -> Dict[str, Any]:
        """Get overall system status."""
        health_status = self.health.get_overall_health()
        active_alerts = self.alerts.get_active_alerts()
        
        # Get recent metrics summary
        recent_time = time.time() - 300  # Last 5 minutes
        recent_requests = len(self.metrics.get_metrics("http_requests_total", since=recent_time))
        recent_errors = len([
            m for m in self.metrics.get_metrics("http_requests_total", since=recent_time)
            if m.tags.get("status_code", "").startswith(("4", "5"))
        ])
        
        return {
            "health": health_status,
            "alerts": {
                "active_count": len(active_alerts),
                "critical_count": len([a for a in active_alerts if a.severity == AlertSeverity.CRITICAL]),
                "error_count": len([a for a in active_alerts if a.severity == AlertSeverity.ERROR])
            },
            "metrics": {
                "recent_requests": recent_requests,
                "recent_errors": recent_errors,
                "error_rate": recent_errors / max(recent_requests, 1)
            },
            "timestamp": time.time()
        }


# Global monitoring system instance
monitoring_system = MonitoringSystem()


# Convenience functions
async def record_metric(name: str, value: float, metric_type: MetricType = MetricType.GAUGE, tags: Optional[Dict[str, str]] = None):
    """Record a metric."""
    await monitoring_system.metrics.record_metric(Metric(
        name=name,
        value=value,
        metric_type=metric_type,
        tags=tags or {}
    ))


async def create_alert(name: str, message: str, severity: AlertSeverity = AlertSeverity.WARNING, tags: Optional[Dict[str, str]] = None):
    """Create an alert."""
    await monitoring_system.alerts.create_alert(Alert(
        name=name,
        message=message,
        severity=severity,
        tags=tags or {}
    ))


def register_health_check(name: str, check_func: Callable[[], Dict[str, Any]]):
    """Register a health check."""
    monitoring_system.health.register_health_check(name, check_func)